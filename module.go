package eleplugin

import (
	//"github.com/davecgh/go-spew/spew"
	_ "unsafe"
)

//go:linkname firstmoduledata runtime.firstmoduledata
//var firstmoduledata moduledata

type functab struct {
	entry   uintptr
	funcoff uintptr
}

// findfunctab is an array of these structures.
// Each bucket represents 4096 bytes of the text segment.
// Each subbucket represents 256 bytes of the text segment.
// To find a function given a pc, locate the bucket and subbucket for
// that pc. Add together the idx and subbucket value to obtain a
// function index. Then scan the functab array starting at that
// index to find the target function.
// This table uses 20 bytes for every 4096 bytes of code, or ~0.5% overhead.
type findfuncbucket struct {
	idx        uint32
	subbuckets [16]byte
}

// Mapping information for secondary text sections
type textsect struct {
	vaddr    uintptr // prelinked section vaddr
	length   uintptr // section length
	baseaddr uintptr // relocated section address
}

type nameOff int32
type typeOff int32
type textOff int32

// A ptabEntry is generated by the compiler for each exported function
// and global variable in the main package of a plugin. It is used to
// initialize the plugin module's symbol map.
type ptabEntry struct {
	name nameOff
	typ  typeOff
}

type modulehash struct {
	modulename   string
	linktimehash string
	runtimehash  *string
}

type bitvector struct {
	n        int32 // # of bits
	bytedata *uint8
}

type stackmap struct {
	n        int32   // number of bitmaps
	nbit     int32   // number of bits in each bitmap
	bytedata [1]byte // bitmaps, each starting on a byte boundary
}

type funcInfo struct {
	*_func
	datap *moduledata
}

const minfunc = 16                 // minimum function size
const pcbucketsize = 256 * minfunc // size of bucket in the pc->func lookup table
const nsub = len(findfuncbucket{}.subbuckets)

//go:linkname step runtime.step
//func step(p []byte, pc *uintptr, val *int32, first bool) (newp []byte, ok bool)

//go:linkname findfunc runtime.findfunc
//func findfunc(pc uintptr) funcInfo

//go:linkname funcdata runtime.funcdata
//func funcdata(f funcInfo, i int32) unsafe.Pointer

//go:linkname funcname runtime.funcname
//func funcname(f funcInfo) string

//go:linkname gostringnocopy runtime.gostringnocopy
//func gostringnocopy(str *byte) string

//go:linkname moduledataverify1 runtime.moduledataverify1
func moduledataverify1(datap *moduledata)

//go:linkname progToPointerMask runtime.progToPointerMask
//func progToPointerMask(prog *byte, size uintptr) bitvector

//func addModule(codeModule *CodeModule) {
//	modules[codeModule.module] = true
//	for datap := &firstmoduledata; ; {
//		if datap.next == nil {
//			datap.next = codeModule.module
//			break
//		}
//		datap = datap.next
//	}
//}

//func removeModule(module interface{}) {
//	prevp := &firstmoduledata
//	for datap := &firstmoduledata; datap != nil; {
//		if datap == module {
//			prevp.next = datap.next
//			break
//		}
//		prevp = datap
//		datap = datap.next
//	}
//	delete(modules, module)
//}

//go:linkname activeModules runtime.activeModules
func activeModules() []*moduledata

//go:linkname modulesinit runtime.modulesinit
func modulesinit()

//go:linkname typelinksinit runtime.typelinksinit
func typelinksinit()

func lastmoduleinit() {
	// Initialize the freshly loaded module.
	modulesinit()
	typelinksinit()

	modules := activeModules()
	var lastModule *moduledata
	for _, module := range modules {
		//fmt.Println("module name:", module.modulename)
		//fmt.Println("has main:", module.hasmain)
		//fmt.Println("has next:", module.next != nil)
		if module.next == nil {
			lastModule = module
		}
	}

	if lastModule == nil {
		panic("can not get last module")
	}


	md := lastModule
	for _, pmd := range modules {
		//if pmd.pluginpath == md.pluginpath {
		//	md.bad = true
		//	return "", nil, "plugin already loaded"
		//}
		if pmd == md {
			continue
		}

		if inRange(pmd.text, pmd.etext, md.text, md.etext) ||
			inRange(pmd.bss, pmd.ebss, md.bss, md.ebss) ||
			inRange(pmd.data, pmd.edata, md.data, md.edata) ||
			inRange(pmd.types, pmd.etypes, md.types, md.etypes) {
			println("plugin: new module data overlaps with previous moduledata")
			println("\tpmd.text-etext=", hex(pmd.text), "-", hex(pmd.etext))
			println("\tpmd.bss-ebss=", hex(pmd.bss), "-", hex(pmd.ebss))
			println("\tpmd.data-edata=", hex(pmd.data), "-", hex(pmd.edata))
			println("\tpmd.types-etypes=", hex(pmd.types), "-", hex(pmd.etypes))
			println("\tmd.text-etext=", hex(md.text), "-", hex(md.etext))
			println("\tmd.bss-ebss=", hex(md.bss), "-", hex(md.ebss))
			println("\tmd.data-edata=", hex(md.data), "-", hex(md.edata))
			println("\tmd.types-etypes=", hex(md.types), "-", hex(md.etypes))
			panic("new module data overlaps with previous moduledata")
		}
	}

	moduledataverify1(lastModule)

	lock(&itabLock)
	for _, i := range lastModule.itablinks {
		itabAdd(i)
	}
	unlock(&itabLock)
}

type hex uint64

// inRange reports whether v0 or v1 are in the range [r0, r1].
func inRange(r0, r1, v0, v1 uintptr) bool {
	return (v0 >= r0 && v0 <= r1) || (v1 >= r0 && v1 <= r1)
}